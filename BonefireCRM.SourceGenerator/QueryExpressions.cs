using BonefireCRM.SourceGenerator.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.CodeDom.Compiler;
using System.Text;

namespace BonefireCRM.SourceGenerator
{
    [Generator]
    public class QueryExpressionsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            //context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            //    "QueryExpressionsForAttribute.g.cs",
            //    SourceText.From(Attributes.QueryExpressionsForAttribute, Encoding.UTF8)));

            var classesToGenerate = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: "BonefireCRM.SourceGenerator.QueryExpressionsForAttribute",
                    predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                    transform: static (ctx, _) => GetClassToGenerate(ctx))
                .WithTrackingName("Provider");

            context.RegisterSourceOutput(classesToGenerate,
                static (spc, source) => Execute(source, spc));
        }

        private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax;
        }

        private static ClassToGenerate GetClassToGenerate(GeneratorAttributeSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.TargetNode;
            var classSymbol = (INamedTypeSymbol)context.SemanticModel.GetDeclaredSymbol(classDeclaration)!;
            
            (var targetTypeName, var targetTypeNamespace) = GetTargetTypeName(classSymbol);

            var properties = new List<PropertiesData>();
            var classMembers = classSymbol.GetMembers();
            foreach (var member in classMembers)
            {
                if (member is IPropertySymbol property && !property.Name.StartsWith("Sort"))
                {
                    var propertyType = property.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    var propertyBaseType = propertyType;
                    if (property.Type.IsValueType)
                    {
                        propertyBaseType = property.Type.BaseType!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    }

                    properties.Add(new(property.Name, propertyType, propertyBaseType));
                }
            }

            var classToGenerate = new ClassToGenerate(
                targetTypeName,
                targetTypeNamespace,
                classSymbol.Name,
                classSymbol.ContainingNamespace.ToString(),
                properties);

            return classToGenerate;
        }

        private static void Execute(ClassToGenerate classToGenerate, SourceProductionContext context)
        {
            var namespaceName = "BonefireCRM.SourceGenerator";

            var source = $$"""
            // <auto-generated/>
            #nullable enable

            using System.Linq.Expressions;
            using {{classToGenerate.TargetTypeNamespace}};
            using {{classToGenerate.DefinitionTypeNamespace}};

            namespace {{namespaceName}};

            public static partial class {{classToGenerate.TargetTypeName}}QueryExpressions
            {
                public static Expression<Func<{{classToGenerate.TargetTypeName}}, bool>> Filter({{classToGenerate.DefinitionTypeName}} filterCriteria)
                {
                    {{FilterMethodBody(classToGenerate)}}
                }

                public static LambdaExpression Sort(string sortCriteria)
                {
                    {{SortMethodBody(classToGenerate)}}
                }
            }
            """;

            context.AddSource($"{classToGenerate.DefinitionTypeName}QueryExpressions.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private static string FilterMethodBody(ClassToGenerate classToGenerate)
        {
            var sb = new StringBuilder();

            using var writer = new StringWriter(sb);
            using var source = new IndentedTextWriter(writer);
            
            source.WriteLine("return x =>");
            source.Indent++;
            source.Indent++;
            source.Indent++;

            var firstIteration = true;
            foreach (var propertyData in classToGenerate.PropertiesData)
            {
                var code = propertyData.BaseType switch
                {
                    "global::System.ValueType" => $"&& (filterCriteria.{propertyData.Name}.HasValue || x.{propertyData.Name} == filterCriteria.{propertyData.Name})",
                    "string" => $"&& (string.IsNullOrEmpty(filterCriteria.{propertyData.Name}) || x.{propertyData.Name} == filterCriteria.{propertyData.Name})",
                    _ => $"// the code for property: {propertyData.Name} could no be generated"
                };

                if (firstIteration)
                {
                    code = code.Substring(3);
                    firstIteration = false;
                }

                source.WriteLine(code);
            }
            source.Write(";");

            return sb.ToString();
        }

        private static string SortMethodBody(ClassToGenerate classToGenerate)
        {
            var sb = new StringBuilder();

            using var writer = new StringWriter(sb);
            using var source = new IndentedTextWriter(writer);

            source.WriteLine("return sortCriteria switch");
            source.Indent++;
            source.Indent++;
            source.WriteLine("{");
            source.Indent++;

            foreach (var propertyData in classToGenerate.PropertiesData)
            {
                source.WriteLine($"nameof({classToGenerate.TargetTypeName}.{propertyData.Name}) => (Expression<Func<{classToGenerate.TargetTypeName}, {propertyData.Type}>>)(x => x.{propertyData.Name}),");
            }

            source.Indent--;
            source.Write("};");

            return sb.ToString();
        }

        private static (string, string) GetTargetTypeName(INamedTypeSymbol classSymbol)
        {
            INamedTypeSymbol targetTypeSymbol = default!;

            foreach (var attributeData in classSymbol.GetAttributes())
            {
                if (attributeData.AttributeClass!.Name == "QueryExpressionsForAttribute")
                {
                    var a = attributeData.AttributeClass.GetMembers();
                    if (attributeData.ConstructorArguments.Length > 0)
                    {
                        targetTypeSymbol = (INamedTypeSymbol) attributeData.ConstructorArguments[0].Value!;
                    }
                    break;
                }
            }

            var targetTypeName = targetTypeSymbol.Name.ToString();
            var targetTypeNamespace = targetTypeSymbol.ContainingNamespace.ToString();

            return (targetTypeName, targetTypeNamespace);
        }
    }

    readonly record struct ClassToGenerate
    {
        public readonly string TargetTypeName = string.Empty;
        public readonly string TargetTypeNamespace = string.Empty;
        public readonly string DefinitionTypeName = string.Empty;
        public readonly string DefinitionTypeNamespace = string.Empty;
        public readonly EquatableArray<PropertiesData> PropertiesData;

        public ClassToGenerate(
            string targetTypeName,
            string targetTypeNamespace,
            string definitionTypeName,
            string definitionTypeNamespace,
            List<PropertiesData> propertiesData)
            : this()
        {
            TargetTypeName = targetTypeName;
            TargetTypeNamespace = targetTypeNamespace;
            DefinitionTypeName = definitionTypeName;
            DefinitionTypeNamespace = definitionTypeNamespace;
            PropertiesData = new([.. propertiesData]);
        }
    }

    readonly record struct PropertiesData
    {
        public readonly string Name;
        public readonly string Type;
        public readonly string BaseType;
        public PropertiesData(string name, string type, string baseType)
        {
            Name = name;
            Type = type;
            BaseType = baseType;
        }
    }
}
